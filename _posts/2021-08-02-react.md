---
title: React深入理解
categories: [文章]
comments: true
---

## 事件系统

### 合成事件的实现机制

在 React 底层，主要对合成事件做了两件事：事件委派和自动绑定

#### 1. 事件委派

React 它并不会把事件处理函数直接绑定到真实节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也提升了很多。

#### 2. 自动绑定

在 React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 this 为当前组件。而且 React 还会对这种引用进行缓存，以达到 CPU 和内存的最优化。在使用 ES6 class 或者纯函数时，这种自动绑定就不复存在，我们需要手动实现 this 的绑定。

### 对比 React 合成事件与 JavaScript 原生事件

#### 1. 事件传播与阻止事件传播

浏览器原生 DOM 事件的传播分为 3 个阶段：事件捕获阶段、目标对象本身的事件处理程序调用以及事件冒泡。事件捕获会优先调用结构树最外层的元素上绑定的事件监听器。然后依次向内调用，一直调用到目标元素上的事件监听器为止。可以 addEventListener 的第三个参数设置为 true，为元素 e 注册捕获事件处理程序，并且在事件传播的第一阶段调用。此外，事件捕获并不是一个通用的技术，在低于 IE9 版本的浏览器中无法使用。而事件冒泡则与事件捕获的表现相反，它会从目标元素向外传播事件，由内向外直至最外层。

可以看出，事件捕获在程序开发中，意义并不大，更致命是它就存在兼容性问题。所以，React 的合成事件则并没有实现事件捕获，仅仅只吃了事件冒泡机制。

阻止原生事件传播需要使用 e.preventDefault()，不过对于不支持该方法的浏览器（IE9 以下），只能使用 e.cancelBubble = true 来阻止。而在 React 合成事件中，只需要使用 e.preventDefault()即可。

#### 2.事件类型

React 合成事件的事件类型是 JavaScript 原生事件类型的一个子集。

#### 3.事件绑定方式

受到 DOM 标准的影响，绑定浏览器原生事件的方式也有很多种

- 直接在 DOM 元素中绑定

```
<button onclick="alert(1);">Test</button>
```

- 在 JavaScript 中，通过为元素的事件属性赋值的方式实现绑定

```
el.onclick = e => {console.log(e)}
```

- 通过事件监听函数来实现绑定

```
e.addEventListener('click', () => {}, false)
e.attachEvent('onclik', () => {})
```

相比而言，React 合成 thia.handleClick 事件的绑定方式则简单的多：：
<button onClick={this.handleClick}>Test</button>

#### 4.事件对象

原生 DOM 事件对象在 W3C 标准和 IE 标准下存在差异，在低版本 IE 浏览器中，只能使用 window.event 来获取事件对象。而在 React 合成事件系统中，不存在这种兼容性问题，在事件处理函数中可以得到一个合成事件对象。
